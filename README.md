该项目的一些细节以及编码思路
一. 一个公共模块（eg:工具类、日志功能等）
二. 编译服务:
    a.编译模块
        1.编译时,在同一时间可能会有多个服务到来,因此对于编译功能的执行,我们需要交给子进程来进行,因此在编译功能中首先进行的应该是创建子进程
        2.在编译时,上层会传入需编译文件的文件名,此时仅仅只有文件名。而我们编译文件时,是需要路径以及文件后缀的,因此我们需要先将我们拿到的文件名添加路径以及后缀
        3.继此,我们可以在公共模块创建工具类,实现一个可以将一个文件名添加它需要的路径以及后缀的类

        补充:
            1.> 对于编译,是有可能出现编译出错的,所以我们还需要一个临时文件来保存可能出现的编译出错信息,因此我们还需要创建一个用来保存编译错误的临时文件,同时将出错信息进行重定向,将原本应该输入到标准错误文件的内容输入到我们创建的临时文件中(也是为了后面方便我们读取错误信息)
            2.> 在父进程中,我们不仅要等待回收子进程,还需要判断是否编译成功,我们知道编译成功的一个标志是会形成可执行程序,因此我们可以判断在指定路径下是否形成了我们需要我可执行的二进制文件,如果形成则代表着编译成功,反之亦然
    b.运行模块
        1.对于一个程序的运行，它其实是包括了三种情况:
            代码跑完，结果正确
            代码跑完，结果不正确
            代码没跑完，异常了
            在我设计的在线oj当中，运行模块是不考虑结果是否正确的，这个是交由测试用例负责判断的。在运行模块中只考虑是否运行完毕
        2.一个程序在默认启动的时候都是会打开三个文件的:
            标准输入流
            标准输出流
            标准错误流
            在这里我们不考虑标准输入流，也就是意味着我们没有设计用户自定义写测试用例，而是只能由设定好的测试用来来判断结果。但是对于另外两个我们是需要进行创建临时文件来保存它们输出的信息的。程序运行结果会输出到我们形成的临时输出文件中，错误会输出到临时错误文件中
        3.运行功能函数返回值设为int，含义:
            A.返回值 > 0: 程序异常了，退出时收到了信号，返回值就是对应的信号编号(在等待子进程时可以得到子进程的退出信息，可以通过status & 0x7f 得到退出时的信号量)
            B.返回值 == 0: 程序正常运行完毕了，结果保存在相应的临时文件中
            C.返回值 < 0: 内部错误 (也就是当出错时，我们手动设置的退出信息 eg: return -1)
        
        注意:
            处理恶意代码(死循环，不断占用系统资源) -> setrlimit系统调用 ----> 限制一些资源的使用
    c.编译+运行
        1.适配用户请求，定义通信协议字段
        2.正确的调用compile and run
        3.形成唯一文件名

        在这里有一些字段需要明确:
            输入:
                code: 用户提交的代码
                input: 用户给自己提交的代码对应的输入，不做处理
                eg: in_json: {"code": "#incldude...", "input": "...."}
                    out_json: {"status_code":"", "reason":"", "stdout":"", "stderr":""}
            输入:
                status: 状态码
                reason: 出错原因
                stdout: 程序运行完的结果
                stderr: 程序运行完的错误结果

        a.我们拿到的数据都是通过http请求过来的，因此首先需要的就是先通过json进行反序列化拿到我们需要的数据(code, input)
        b.当拿到我们需要的数据后，就可以开始创建我们需要的文件了，但是同一时间可能会有多个请求，因此我们要保证我们形成的文件名是唯一的
        c.当有了文件名和代码后，我们就可以向这个文件中写入我们获取到的代码了，这样完成之后我们就得到了一个code.cc文件，进而就可以进行编译了
        d.对各个模块进行差错处理
            code > 0: 进程收到了信号导致异常崩溃
            code < 0: 整个过程非运行报错(代码为空、编译报错等)
            code = 0: 整个过程全部完成
        补充:
            1.getline不保存分隔符
            2.《atomic》 -> atomic_uint id(0)
            3. 清理临时文件: 由于异常情况的发生，有些临时文件是有可能不会发生的。unlink -> 删除文件的系统调用
    d.引入httplib第三方库 ----- > 阻塞式的多线程库
        在设置响应时，是需要传入set_content文本类型的，json对应的文本类型是: application/json;charset=utf-8

三. oj_server
    1.基于MAV结构进行设计
        M: Model，通常是和数据交互的模块，比如，对题库进行增删查改(文件版，MySQL)
        V: View，通常是拿到数据后，要进行构建网页，渲染网页的内容，展示给用户的(浏览器)
        C: Control，控制器，就是我们核心的业务逻辑
    2.oj_server: 
        用户请求的路由功能，分为三部分:
            1.获取题目列表: 
            2.用户根据题目编号，获取题目的内容
                获取url中的数字部分 --- > 在Request中有一个matches字段，通过matches[1] 可以获取数字
            3.用户提交的代码，使用我们的判题功能(a.每道题的测试用例 b.compile_run)
                设置目录 --- > set_base_dir("你的默认目录")
    3.文件版题目设计 --- model模块
        a.题目的编号
        b.题目的难度
        c.题目的标题
        d.题目的描述
        e.时、空复杂度
        由两批文件构成:
            1.题目列表(不需要题目的内容) : [ 题目的编号  目的标题  题目的难度  题目所在路径  题目时间限制  题目空间限制 ]
            2.题目的描述，题目的预设值代码(编写代码的地方)，测试用例代码

        *** 思考: 我们是仿照leetcode的形式进行设计的，在leetcode上，基本上都是只实现某一个函数或成员函数，并不是一个完整的工程代码。而同时我们还需要设计测试用例来判断用户写的代码是否正确，因此我们向compile_run模块传输的数据应该是用户写的代码 + 我们设计的测试用例。(多个.hpp文件一起编译时，是会整合到一起进行编译链接的，因此我们是可以将用户写的代码和我们设计的测试用例代码分开写到两个.hpp文件当中的) 

        1. oj_model: 根据题目list文件，加载所有的题目信息到内存中。 主要用来和数据进行交互，对外提供访问数据的接口
            a.加载题目信息
            b.得到全部题目信息
            c.得到指定题目信息
        
        control模块: 用来管理model模块和view模块的，是将model模块获取的数据通过view模块进行网页渲染
            a.得到所有题目数据 --- 再通过view模块进行渲染
            b.得到指定题目数据

        view模块:
            内置两个成员函数: a. AllExpandHtml  b. OneExpandHtml



Thread-lib:
    boost/algorithm/string.hpp --- > boost::split() 
        参数列表解释: vector数组(将拆分后的一个一个字符存放到vector中), 被分隔字符串, 分隔符(is_any_of(分隔符)), boost::algorithm::token_compress_on(去除多余的分隔符 --- > 两个字符间有多个连续的分隔符) ---------------- boost::algorithm::token_compress_off 去掉分隔符压缩
    
    ctemplate --- > C/C++的网页渲染工具
    eg:
        #include <ctemplate/template.h>
        #include <iostream>
        #include <string>

        int main()
        {
            std::string in_html = "./test.html";
            std::string value = "hello word";

            // 形成数据字典
            ctemplate::TemplateDictionary root("test"); // 类比成 unordered_map<> test
            root.SetValue("key", value);                // test.insert({"key", value})

            // 获取被渲染对象
            ctemplate::Template *tpl = ctemplate::Template::GetTemplate(in_html, ctemplate::DO_NOT_STRIP/*保持原貌, 不去除空行*/);

            // 添加数据字典到网页中
            std::string out_html;
            tpl->Expand(&out_html, &root);

            // 完成渲染
            std::cout << out_html << std::endl;
            return 0;
        }
    
