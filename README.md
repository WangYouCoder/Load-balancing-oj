该项目的一些细节以及编码思路
一. 一个公共模块（eg:工具类、日志功能等）
二. 编译服务:
    a.编译模块
        1.编译时,在同一时间可能会有多个服务到来,因此对于编译功能的执行,我们需要交给子进程来进行,因此在编译功能中首先进行的应该是创建子进程
        2.在编译时,上层会传入需编译文件的文件名,此时仅仅只有文件名。而我们编译文件时,是需要路径以及文件后缀的,因此我们需要先将我们拿到的文件名添加路径以及后缀
        3.继此,我们可以在公共模块创建工具类,实现一个可以将一个文件名添加它需要的路径以及后缀的类

        补充:
            1.> 对于编译,是有可能出现编译出错的,所以我们还需要一个临时文件来保存可能出现的编译出错信息,因此我们还需要创建一个用来保存编译错误的临时文件,同时将出错信息进行重定向,将原本应该输入到标准错误文件的内容输入到我们创建的临时文件中(也是为了后面方便我们读取错误信息)
            2.> 在父进程中,我们不仅要等待回收子进程,还需要判断是否编译成功,我们知道编译成功的一个标志是会形成可执行程序,因此我们可以判断在指定路径下是否形成了我们需要我可执行的二进制文件,如果形成则代表着编译成功,反之亦然
    b.运行模块
        1.对于一个程序的运行，它其实是包括了三种情况:
            代码跑完，结果正确
            代码跑完，结果不正确
            代码没跑完，异常了
            在我设计的在线oj当中，运行模块是不考虑结果是否正确的，这个是交由测试用例负责判断的。在运行模块中只考虑是否运行完毕
        2.一个程序在默认启动的时候都是会打开三个文件的:
            标准输入流
            标准输出流
            标准错误流
            在这里我们不考虑标准输入流，也就是意味着我们没有设计用户自定义写测试用例，而是只能由设定好的测试用来来判断结果。但是对于另外两个我们是需要进行创建临时文件来保存它们输出的信息的。程序运行结果会输出到我们形成的临时输出文件中，错误会输出到临时错误文件中
        3.运行功能函数返回值设为int，含义:
            A.返回值 > 0: 程序异常了，退出时收到了信号，返回值就是对应的信号编号(在等待子进程时可以得到子进程的退出信息，可以通过status & 0x7f 得到退出时的信号量)
            B.返回值 == 0: 程序正常运行完毕了，结果保存在相应的临时文件中
            C.返回值 < 0: 内部错误 (也就是当出错时，我们手动设置的退出信息 eg: return -1)
        
        注意:
            处理恶意代码(死循环，不断占用系统资源) -> setrlimit系统调用 ----> 限制一些资源的使用
    c.编译+运行
        1.适配用户请求，定义通信协议字段
        2.正确的调用compile and run
        3.形成唯一文件名

        在这里有一些字段需要明确:
            输入:
                code: 用户提交的代码
                input: 用户给自己提交的代码对应的输入，不做处理
                eg: in_json: {"code": "#incldude...", "input": "...."}
                    out_json: {"status_code":"", "reason":"", "stdout":"", "stderr":""}
            输入:
                status: 状态码
                reason: 出错原因
                stdout: 程序运行完的结果
                stderr: 程序运行完的错误结果

        a.我们拿到的数据都是通过http请求过来的，因此首先需要的就是先通过json进行反序列化拿到我们需要的数据(code, input)
        b.当拿到我们需要的数据后，就可以开始创建我们需要的文件了，但是同一时间可能会有多个请求，因此我们要保证我们形成的文件名是唯一的
        c.当有了文件名和代码后，我们就可以向这个文件中写入我们获取到的代码了，这样完成之后我们就得到了一个code.cc文件，进而就可以进行编译了
        d.对各个模块进行差错处理
            code > 0: 进程收到了信号导致异常崩溃
            code < 0: 整个过程非运行报错(代码为空、编译报错等)
            code = 0: 整个过程全部完成
        补充:
            1.getline不保存分隔符
            2.《atomic》 -> atomic_uint id(0)
            3. 
三. oj_server
